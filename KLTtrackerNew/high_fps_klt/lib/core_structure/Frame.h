//
// Created by iqmatic on 2016-03-15.
//

#ifndef IQMATIC_FRAME_H
#define IQMATIC_FRAME_H

#include <vector>
#include <map>
#include <opencv2/opencv.hpp>
#include "PoseGraph_defs.h"
#include "Landmark.h"
//#include "Camera.h"

namespace iqmatic {

using iqmatic::camera::Camera;
/*
struct GTObservation;
*/
class Frame
{
public:
	/*
    /// Simulated observations generated by SimSource::getData(), that have not been assigned to a Landmark yet.
    std::vector<GTObservation> src_gt_observations;
    /// Simulated observations assigned to landmarks, in SimTracker::trackNewFrames()
    std::map<LandmarkID, GTObservation> gt_observations;
	*/
    bool has_ground_truth;


    Frame() : has_ground_truth(false)
    {
    };

    Frame(const cv::Mat &gray, const cv::Mat &rgb)
            : has_ground_truth(false), gray(gray), rgb(rgb)
    {
    }

    virtual ~Frame()
    {
    }

	static sFrame create(const cv::Mat &gray, const cv::Mat &rgb);

	void newObservation(sLandmark lm, const cv::Point2f& position, cv::Mat descriptor = cv::Mat());
    void addObservation(sObservation obs);
   // void addGTObservation(const GTObservation& gt_obs);
    void removeObservation(sObservation obs);

    const cv::Mat& getGray() const
    {
        return gray;
    }

    const cv::Mat& getRgb() const
    {
        return rgb;
    }

    Camera *getCamera() const
    {
        return camera.get();
    }

    Timepoint* getTp() const
    {
        return tp;
    }

   /* const vector<sObservation>& getObservations() const
    {
        return observations;
    }*/

    const std::map<LandmarkID, sObservation>& getObservation_map() const
    {
        return observation_map;
    }

    void setCamera(const std::shared_ptr<Camera>& camera)
    {
        Frame::camera = camera;
    }

    void setTp(Timepoint *tp) {
        Frame::tp = tp;
    }
	uint frame_num, timestamp;

public:
//private:
	
    cv::Mat gray;
    cv::Mat rgb;

    std::shared_ptr<Camera> camera;
    Timepoint *tp;
    //std::vector<sObservation> observations;
    std::map<LandmarkID, sObservation> observation_map;
};

} // iqmatic::

#endif //IQMATIC_FRAME_H
